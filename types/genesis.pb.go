// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provlabs/vault/v1/genesis.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueueEntry is a (time, addr) pair used by the vault payout deferral queue.
type QueueEntry struct {
	// time is the UNIX timestamp (in seconds) when the entry becomes eligible.
	Time uint64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// addr is the bech32 vault address associated with the entry.
	Addr string `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *QueueEntry) Reset()         { *m = QueueEntry{} }
func (m *QueueEntry) String() string { return proto.CompactTextString(m) }
func (*QueueEntry) ProtoMessage()    {}
func (*QueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b040ce5c03c7bf33, []int{0}
}
func (m *QueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueEntry.Merge(m, src)
}
func (m *QueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *QueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_QueueEntry proto.InternalMessageInfo

func (m *QueueEntry) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *QueueEntry) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// PendingSwapOutQueueEntry represents a single pending swap-out request queued for later processing.
type PendingSwapOutQueueEntry struct {
	// time is the UNIX timestamp (in seconds) when this pending swap-out was enqueued or becomes eligible.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	// id is the unique identifier of the pending swap-out request.
	Id uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// swap_out contains the pending swap-out details.
	SwapOut PendingSwapOut `protobuf:"bytes,3,opt,name=swap_out,json=swapOut,proto3" json:"swap_out"`
}

func (m *PendingSwapOutQueueEntry) Reset()         { *m = PendingSwapOutQueueEntry{} }
func (m *PendingSwapOutQueueEntry) String() string { return proto.CompactTextString(m) }
func (*PendingSwapOutQueueEntry) ProtoMessage()    {}
func (*PendingSwapOutQueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b040ce5c03c7bf33, []int{1}
}
func (m *PendingSwapOutQueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingSwapOutQueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingSwapOutQueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingSwapOutQueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingSwapOutQueueEntry.Merge(m, src)
}
func (m *PendingSwapOutQueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *PendingSwapOutQueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingSwapOutQueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PendingSwapOutQueueEntry proto.InternalMessageInfo

func (m *PendingSwapOutQueueEntry) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PendingSwapOutQueueEntry) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PendingSwapOutQueueEntry) GetSwapOut() PendingSwapOut {
	if m != nil {
		return m.SwapOut
	}
	return PendingSwapOut{}
}

// PendingSwapOutQueue holds the latest sequence number and all queued swap-out entries.
type PendingSwapOutQueue struct {
	// latest_sequence_number is the most recently assigned pending swap-out ID.
	LatestSequenceNumber uint64 `protobuf:"varint,1,opt,name=latest_sequence_number,json=latestSequenceNumber,proto3" json:"latest_sequence_number,omitempty"`
	// entries contains all currently queued pending swap-out entries.
	Entries []PendingSwapOutQueueEntry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries"`
}

func (m *PendingSwapOutQueue) Reset()         { *m = PendingSwapOutQueue{} }
func (m *PendingSwapOutQueue) String() string { return proto.CompactTextString(m) }
func (*PendingSwapOutQueue) ProtoMessage()    {}
func (*PendingSwapOutQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b040ce5c03c7bf33, []int{2}
}
func (m *PendingSwapOutQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PendingSwapOutQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PendingSwapOutQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PendingSwapOutQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PendingSwapOutQueue.Merge(m, src)
}
func (m *PendingSwapOutQueue) XXX_Size() int {
	return m.Size()
}
func (m *PendingSwapOutQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_PendingSwapOutQueue.DiscardUnknown(m)
}

var xxx_messageInfo_PendingSwapOutQueue proto.InternalMessageInfo

func (m *PendingSwapOutQueue) GetLatestSequenceNumber() uint64 {
	if m != nil {
		return m.LatestSequenceNumber
	}
	return 0
}

func (m *PendingSwapOutQueue) GetEntries() []PendingSwapOutQueueEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// GenesisState defines the vault module's genesis state.
// NOTE: payout verification queue is not imported or exported.  It will always be empty after endblocker processes it.
type GenesisState struct {
	// vaults defines the vaults that exist at genesis.
	Vaults []VaultAccount `protobuf:"bytes,1,rep,name=vaults,proto3" json:"vaults"`
	// payout_timeout_queue contains (time, addr) entries for vaults that are
	// temporarily deferred from automatic payout/interest verification until the
	// given UNIX timestamp (seconds). These entries are re-enqueued on InitGenesis.
	PayoutTimeoutQueue []QueueEntry `protobuf:"bytes,2,rep,name=payout_timeout_queue,json=payoutTimeoutQueue,proto3" json:"payout_timeout_queue"`
	// pending_swap_out_queue contains entries for pending swap outs.
	PendingSwapOutQueue PendingSwapOutQueue `protobuf:"bytes,3,opt,name=pending_swap_out_queue,json=pendingSwapOutQueue,proto3" json:"pending_swap_out_queue"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b040ce5c03c7bf33, []int{3}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetVaults() []VaultAccount {
	if m != nil {
		return m.Vaults
	}
	return nil
}

func (m *GenesisState) GetPayoutTimeoutQueue() []QueueEntry {
	if m != nil {
		return m.PayoutTimeoutQueue
	}
	return nil
}

func (m *GenesisState) GetPendingSwapOutQueue() PendingSwapOutQueue {
	if m != nil {
		return m.PendingSwapOutQueue
	}
	return PendingSwapOutQueue{}
}

func init() {
	proto.RegisterType((*QueueEntry)(nil), "provlabs.vault.v1.QueueEntry")
	proto.RegisterType((*PendingSwapOutQueueEntry)(nil), "provlabs.vault.v1.PendingSwapOutQueueEntry")
	proto.RegisterType((*PendingSwapOutQueue)(nil), "provlabs.vault.v1.PendingSwapOutQueue")
	proto.RegisterType((*GenesisState)(nil), "provlabs.vault.v1.GenesisState")
}

func init() { proto.RegisterFile("provlabs/vault/v1/genesis.proto", fileDescriptor_b040ce5c03c7bf33) }

var fileDescriptor_b040ce5c03c7bf33 = []byte{
	// 424 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xbf, 0x8b, 0xd4, 0x40,
	0x14, 0xc7, 0x33, 0xd9, 0x70, 0xa7, 0x73, 0x22, 0x38, 0xb7, 0x1c, 0xe1, 0xe0, 0x92, 0x98, 0x42,
	0x02, 0x42, 0xc2, 0x9d, 0xd7, 0x58, 0x58, 0x78, 0x20, 0x16, 0x82, 0x3f, 0xb2, 0x6a, 0x61, 0x13,
	0x26, 0xc9, 0x10, 0x03, 0xbb, 0x33, 0x73, 0x99, 0x99, 0x1c, 0xdb, 0xda, 0xd8, 0x5a, 0xfa, 0x27,
	0x5d, 0x79, 0xa5, 0x95, 0xc8, 0xee, 0x3f, 0x22, 0x99, 0x99, 0x20, 0xba, 0x11, 0xad, 0xf6, 0x6d,
	0xbe, 0xef, 0x7d, 0xde, 0xfb, 0xbe, 0x37, 0x30, 0xe4, 0x1d, 0xeb, 0x97, 0xb8, 0x14, 0x59, 0x8f,
	0xd5, 0x52, 0x66, 0xfd, 0x69, 0xd6, 0x10, 0x4a, 0x44, 0x2b, 0x52, 0xde, 0x31, 0xc9, 0xd0, 0xbd,
	0x31, 0x21, 0xd5, 0x09, 0x69, 0x7f, 0x7a, 0x3c, 0x6f, 0x58, 0xc3, 0xb4, 0x9a, 0x0d, 0x91, 0x49,
	0x3c, 0x3e, 0xd9, 0x25, 0x99, 0x0a, 0x2d, 0xc7, 0xe7, 0x10, 0xbe, 0x51, 0x44, 0x91, 0x67, 0x54,
	0x76, 0x6b, 0x84, 0xa0, 0x27, 0xdb, 0x15, 0xf1, 0x41, 0x04, 0x12, 0x2f, 0xd7, 0xf1, 0xf0, 0x0d,
	0xd7, 0x75, 0xe7, 0xbb, 0x11, 0x48, 0x6e, 0xe7, 0x3a, 0x8e, 0x3f, 0x01, 0xe8, 0xbf, 0x26, 0xb4,
	0x6e, 0x69, 0xb3, 0xb8, 0xc2, 0xfc, 0x95, 0x92, 0x7f, 0x81, 0xcc, 0x2c, 0xe4, 0x2e, 0x74, 0xdb,
	0x5a, 0x23, 0xbc, 0xdc, 0x6d, 0x6b, 0x74, 0x01, 0x6f, 0x89, 0x2b, 0xcc, 0x0b, 0xa6, 0xa4, 0x3f,
	0x8b, 0x40, 0x72, 0x70, 0x76, 0x3f, 0xdd, 0x71, 0x94, 0xfe, 0xde, 0xe2, 0xc2, 0xbb, 0xfe, 0x1e,
	0x3a, 0xf9, 0xbe, 0x30, 0x7f, 0xe3, 0xaf, 0x00, 0x1e, 0x4e, 0x0c, 0x81, 0xce, 0xe1, 0xd1, 0x12,
	0x4b, 0x22, 0x64, 0x21, 0xc8, 0xa5, 0x22, 0xb4, 0x22, 0x05, 0x55, 0xab, 0x92, 0x74, 0xd6, 0xd6,
	0xdc, 0xa8, 0x0b, 0x2b, 0xbe, 0xd4, 0x1a, 0x7a, 0x01, 0xf7, 0x09, 0x95, 0x5d, 0x4b, 0x84, 0xef,
	0x46, 0xb3, 0xe4, 0xe0, 0xec, 0xe1, 0x3f, 0x07, 0xfa, 0xe5, 0x79, 0x1c, 0xcd, 0x12, 0xe2, 0xcf,
	0x2e, 0xbc, 0xf3, 0xdc, 0xdc, 0x6b, 0x21, 0xb1, 0x24, 0xe8, 0x09, 0xdc, 0xd3, 0x10, 0xe1, 0x03,
	0x0d, 0x0f, 0x27, 0xe0, 0xef, 0x87, 0xe0, 0x69, 0x55, 0x31, 0x45, 0x47, 0xaf, 0xb6, 0x08, 0xbd,
	0x83, 0x73, 0x8e, 0xd7, 0x4c, 0xc9, 0x62, 0xd8, 0xe6, 0xf0, 0x7b, 0x39, 0xf4, 0xb6, 0x93, 0x9e,
	0x4c, 0xc0, 0x76, 0x66, 0x43, 0x06, 0xf0, 0xd6, 0xd4, 0x9b, 0x4d, 0x61, 0x78, 0xc4, 0x8d, 0xa3,
	0x62, 0xbc, 0x86, 0x05, 0x9b, 0x9b, 0x3c, 0xf8, 0xbf, 0x15, 0xd8, 0x0e, 0x87, 0x7c, 0x42, 0x7a,
	0x7c, 0xbd, 0x09, 0xc0, 0xcd, 0x26, 0x00, 0x3f, 0x36, 0x01, 0xf8, 0xb2, 0x0d, 0x9c, 0x9b, 0x6d,
	0xe0, 0x7c, 0xdb, 0x06, 0xce, 0x87, 0xb0, 0x69, 0xe5, 0x47, 0x55, 0xa6, 0x15, 0x5b, 0x65, 0x7f,
	0xbc, 0x51, 0xb9, 0xe6, 0x44, 0x94, 0x7b, 0xfa, 0x85, 0x3e, 0xfa, 0x19, 0x00, 0x00, 0xff, 0xff,
	0xcb, 0x57, 0x6a, 0x8a, 0x0c, 0x03, 0x00, 0x00,
}

func (m *QueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGenesis(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Time != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingSwapOutQueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingSwapOutQueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingSwapOutQueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SwapOut.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Id != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Time != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PendingSwapOutQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PendingSwapOutQueue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PendingSwapOutQueue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LatestSequenceNumber != 0 {
		i = encodeVarintGenesis(dAtA, i, uint64(m.LatestSequenceNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PendingSwapOutQueue.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGenesis(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PayoutTimeoutQueue) > 0 {
		for iNdEx := len(m.PayoutTimeoutQueue) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PayoutTimeoutQueue[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Vaults) > 0 {
		for iNdEx := len(m.Vaults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vaults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGenesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintGenesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovGenesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGenesis(uint64(m.Time))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGenesis(uint64(l))
	}
	return n
}

func (m *PendingSwapOutQueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGenesis(uint64(m.Time))
	}
	if m.Id != 0 {
		n += 1 + sovGenesis(uint64(m.Id))
	}
	l = m.SwapOut.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func (m *PendingSwapOutQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LatestSequenceNumber != 0 {
		n += 1 + sovGenesis(uint64(m.LatestSequenceNumber))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	return n
}

func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vaults) > 0 {
		for _, e := range m.Vaults {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	if len(m.PayoutTimeoutQueue) > 0 {
		for _, e := range m.PayoutTimeoutQueue {
			l = e.Size()
			n += 1 + l + sovGenesis(uint64(l))
		}
	}
	l = m.PendingSwapOutQueue.Size()
	n += 1 + l + sovGenesis(uint64(l))
	return n
}

func sovGenesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGenesis(x uint64) (n int) {
	return sovGenesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingSwapOutQueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingSwapOutQueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingSwapOutQueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingSwapOutQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingSwapOutQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingSwapOutQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestSequenceNumber", wireType)
			}
			m.LatestSequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestSequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, PendingSwapOutQueueEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vaults = append(m.Vaults, VaultAccount{})
			if err := m.Vaults[len(m.Vaults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutTimeoutQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutTimeoutQueue = append(m.PayoutTimeoutQueue, QueueEntry{})
			if err := m.PayoutTimeoutQueue[len(m.PayoutTimeoutQueue)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingSwapOutQueue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGenesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGenesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PendingSwapOutQueue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGenesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGenesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGenesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGenesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGenesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGenesis
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGenesis
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGenesis
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGenesis        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGenesis          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGenesis = fmt.Errorf("proto: unexpected end of group")
)
