// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: provlabs/vault/v1/events.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventDeposit is an event emitted when assets are deposited into a vault.
type EventDeposit struct {
	// caller is the address of the account that initiated the deposit.
	Caller string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	// owner is the address of the account that will receive the minted shares.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// assets is the coins amount string of the underlying assets that were deposited.
	Assets string `protobuf:"bytes,3,opt,name=assets,proto3" json:"assets,omitempty"`
	// shares is the coins amount string of the vault shares that were minted.
	Shares string `protobuf:"bytes,4,opt,name=shares,proto3" json:"shares,omitempty"`
	// vault_id is the numerical identifier of the vault.
	VaultId uint32 `protobuf:"varint,5,opt,name=vault_id,json=vaultId,proto3" json:"vault_id,omitempty"`
}

func (m *EventDeposit) Reset()         { *m = EventDeposit{} }
func (m *EventDeposit) String() string { return proto.CompactTextString(m) }
func (*EventDeposit) ProtoMessage()    {}
func (*EventDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{0}
}
func (m *EventDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDeposit.Merge(m, src)
}
func (m *EventDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventDeposit proto.InternalMessageInfo

func (m *EventDeposit) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *EventDeposit) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventDeposit) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventDeposit) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

func (m *EventDeposit) GetVaultId() uint32 {
	if m != nil {
		return m.VaultId
	}
	return 0
}

// EventWithdraw is an event emitted when assets are withdrawn from a vault.
type EventWithdraw struct {
	// caller is the address of the account that initiated the withdrawal.
	Caller string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	// receiver is the address of the account that will receive the underlying assets.
	Receiver string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	// owner is the address of the account from which the shares were burned.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// assets is the coins amount string of the underlying assets that were withdrawn.
	Assets string `protobuf:"bytes,4,opt,name=assets,proto3" json:"assets,omitempty"`
	// shares is the coins amount string of the vault shares that were burned.
	Shares string `protobuf:"bytes,5,opt,name=shares,proto3" json:"shares,omitempty"`
	// vault_id is the numerical identifier of the vault.
	VaultId uint32 `protobuf:"varint,6,opt,name=vault_id,json=vaultId,proto3" json:"vault_id,omitempty"`
}

func (m *EventWithdraw) Reset()         { *m = EventWithdraw{} }
func (m *EventWithdraw) String() string { return proto.CompactTextString(m) }
func (*EventWithdraw) ProtoMessage()    {}
func (*EventWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{1}
}
func (m *EventWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdraw.Merge(m, src)
}
func (m *EventWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdraw proto.InternalMessageInfo

func (m *EventWithdraw) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *EventWithdraw) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *EventWithdraw) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventWithdraw) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventWithdraw) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

func (m *EventWithdraw) GetVaultId() uint32 {
	if m != nil {
		return m.VaultId
	}
	return 0
}

// EventVaultCreated is an event emitted when a vault is created.
type EventVaultCreated struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that manages the vault.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// share_denom is the name of the assets created by the vault used for distribution.
	ShareDenom string `protobuf:"bytes,3,opt,name=share_denom,json=shareDenom,proto3" json:"share_denom,omitempty"`
	// underlying_asset is the vaultâ€™s primary collateral and valuation/base denomination.
	UnderlyingAsset string `protobuf:"bytes,4,opt,name=underlying_asset,json=underlyingAsset,proto3" json:"underlying_asset,omitempty"`
}

func (m *EventVaultCreated) Reset()         { *m = EventVaultCreated{} }
func (m *EventVaultCreated) String() string { return proto.CompactTextString(m) }
func (*EventVaultCreated) ProtoMessage()    {}
func (*EventVaultCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{2}
}
func (m *EventVaultCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVaultCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVaultCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVaultCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVaultCreated.Merge(m, src)
}
func (m *EventVaultCreated) XXX_Size() int {
	return m.Size()
}
func (m *EventVaultCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVaultCreated.DiscardUnknown(m)
}

var xxx_messageInfo_EventVaultCreated proto.InternalMessageInfo

func (m *EventVaultCreated) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventVaultCreated) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventVaultCreated) GetShareDenom() string {
	if m != nil {
		return m.ShareDenom
	}
	return ""
}

func (m *EventVaultCreated) GetUnderlyingAsset() string {
	if m != nil {
		return m.UnderlyingAsset
	}
	return ""
}

// EventSwapIn is an event emitted when assets are swapped in for vault shares.
type EventSwapIn struct {
	// owner is the address of the account that initiated the swap.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// amount_in is the amount of underlying assets that were swapped in.
	AmountIn string `protobuf:"bytes,2,opt,name=amount_in,json=amountIn,proto3" json:"amount_in,omitempty"`
	// shares_received is the amount of vault shares that were minted.
	SharesReceived string `protobuf:"bytes,3,opt,name=shares_received,json=sharesReceived,proto3" json:"shares_received,omitempty"`
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,4,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
}

func (m *EventSwapIn) Reset()         { *m = EventSwapIn{} }
func (m *EventSwapIn) String() string { return proto.CompactTextString(m) }
func (*EventSwapIn) ProtoMessage()    {}
func (*EventSwapIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{3}
}
func (m *EventSwapIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapIn.Merge(m, src)
}
func (m *EventSwapIn) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapIn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapIn.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapIn proto.InternalMessageInfo

func (m *EventSwapIn) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventSwapIn) GetAmountIn() string {
	if m != nil {
		return m.AmountIn
	}
	return ""
}

func (m *EventSwapIn) GetSharesReceived() string {
	if m != nil {
		return m.SharesReceived
	}
	return ""
}

func (m *EventSwapIn) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

// EventSwapOut is an event emitted when vault shares are swapped out for underlying assets.
type EventSwapOut struct {
	// owner is the address of the account that initiated the swap.
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// shares_burned is the amount of vault shares that were burned.
	SharesBurned string `protobuf:"bytes,2,opt,name=shares_burned,json=sharesBurned,proto3" json:"shares_burned,omitempty"`
	// amount_out is the amount of underlying assets that were sent to the recipient.
	AmountOut string `protobuf:"bytes,3,opt,name=amount_out,json=amountOut,proto3" json:"amount_out,omitempty"`
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,4,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
}

func (m *EventSwapOut) Reset()         { *m = EventSwapOut{} }
func (m *EventSwapOut) String() string { return proto.CompactTextString(m) }
func (*EventSwapOut) ProtoMessage()    {}
func (*EventSwapOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{4}
}
func (m *EventSwapOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapOut.Merge(m, src)
}
func (m *EventSwapOut) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapOut) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapOut.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapOut proto.InternalMessageInfo

func (m *EventSwapOut) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventSwapOut) GetSharesBurned() string {
	if m != nil {
		return m.SharesBurned
	}
	return ""
}

func (m *EventSwapOut) GetAmountOut() string {
	if m != nil {
		return m.AmountOut
	}
	return ""
}

func (m *EventSwapOut) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

// EventVaultReconcile is an event emitted when a vault's interest is reconciled.
type EventVaultReconcile struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// principal_before is the principal amount before applying interest.
	PrincipalBefore string `protobuf:"bytes,2,opt,name=principal_before,json=principalBefore,proto3" json:"principal_before,omitempty"`
	// principal_after is the principal amount after applying interest.
	PrincipalAfter string `protobuf:"bytes,3,opt,name=principal_after,json=principalAfter,proto3" json:"principal_after,omitempty"`
	// rate is a decimal string (e.g., "0.9" for 90% and "0.9001353" for 90.01353%) representing annual interest rate for the period.
	Rate string `protobuf:"bytes,4,opt,name=rate,proto3" json:"rate,omitempty"`
	// time is the payout duration in seconds.
	Time int64 `protobuf:"varint,5,opt,name=time,proto3" json:"time,omitempty"`
	// interest_earned is the interest amount (can be positive or negative).
	InterestEarned string `protobuf:"bytes,6,opt,name=interest_earned,json=interestEarned,proto3" json:"interest_earned,omitempty"`
}

func (m *EventVaultReconcile) Reset()         { *m = EventVaultReconcile{} }
func (m *EventVaultReconcile) String() string { return proto.CompactTextString(m) }
func (*EventVaultReconcile) ProtoMessage()    {}
func (*EventVaultReconcile) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{5}
}
func (m *EventVaultReconcile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVaultReconcile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVaultReconcile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVaultReconcile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVaultReconcile.Merge(m, src)
}
func (m *EventVaultReconcile) XXX_Size() int {
	return m.Size()
}
func (m *EventVaultReconcile) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVaultReconcile.DiscardUnknown(m)
}

var xxx_messageInfo_EventVaultReconcile proto.InternalMessageInfo

func (m *EventVaultReconcile) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventVaultReconcile) GetPrincipalBefore() string {
	if m != nil {
		return m.PrincipalBefore
	}
	return ""
}

func (m *EventVaultReconcile) GetPrincipalAfter() string {
	if m != nil {
		return m.PrincipalAfter
	}
	return ""
}

func (m *EventVaultReconcile) GetRate() string {
	if m != nil {
		return m.Rate
	}
	return ""
}

func (m *EventVaultReconcile) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *EventVaultReconcile) GetInterestEarned() string {
	if m != nil {
		return m.InterestEarned
	}
	return ""
}

// EventVaultInterestChange is an event emitted when a vault's interest rate is changed.
type EventVaultInterestChange struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// current_rate is a decimal string (e.g., "0.9" for 90% and "0.9001353" for 90.01353%) representing the actual annual interest rate the vault is using.
	CurrentRate string `protobuf:"bytes,2,opt,name=current_rate,json=currentRate,proto3" json:"current_rate,omitempty"`
	// desired_rate is a decimal string (e.g., "0.9" for 90% and "0.9001353" for 90.01353%) representing the the annual interest rate the admin wants to use.
	DesiredRate string `protobuf:"bytes,3,opt,name=desired_rate,json=desiredRate,proto3" json:"desired_rate,omitempty"`
}

func (m *EventVaultInterestChange) Reset()         { *m = EventVaultInterestChange{} }
func (m *EventVaultInterestChange) String() string { return proto.CompactTextString(m) }
func (*EventVaultInterestChange) ProtoMessage()    {}
func (*EventVaultInterestChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{6}
}
func (m *EventVaultInterestChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVaultInterestChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVaultInterestChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVaultInterestChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVaultInterestChange.Merge(m, src)
}
func (m *EventVaultInterestChange) XXX_Size() int {
	return m.Size()
}
func (m *EventVaultInterestChange) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVaultInterestChange.DiscardUnknown(m)
}

var xxx_messageInfo_EventVaultInterestChange proto.InternalMessageInfo

func (m *EventVaultInterestChange) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventVaultInterestChange) GetCurrentRate() string {
	if m != nil {
		return m.CurrentRate
	}
	return ""
}

func (m *EventVaultInterestChange) GetDesiredRate() string {
	if m != nil {
		return m.DesiredRate
	}
	return ""
}

// EventInterestDeposit is an event emitted when funds are deposited for paying interest.
type EventInterestDeposit struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that deposited the funds.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// amount is the amount of funds deposited.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventInterestDeposit) Reset()         { *m = EventInterestDeposit{} }
func (m *EventInterestDeposit) String() string { return proto.CompactTextString(m) }
func (*EventInterestDeposit) ProtoMessage()    {}
func (*EventInterestDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{7}
}
func (m *EventInterestDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventInterestDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventInterestDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventInterestDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventInterestDeposit.Merge(m, src)
}
func (m *EventInterestDeposit) XXX_Size() int {
	return m.Size()
}
func (m *EventInterestDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_EventInterestDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_EventInterestDeposit proto.InternalMessageInfo

func (m *EventInterestDeposit) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventInterestDeposit) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventInterestDeposit) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// EventInterestWithdrawal is an event emitted when unused interest funds are withdrawn.
type EventInterestWithdrawal struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that withdrew the funds.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// amount is the amount of funds withdrawn.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventInterestWithdrawal) Reset()         { *m = EventInterestWithdrawal{} }
func (m *EventInterestWithdrawal) String() string { return proto.CompactTextString(m) }
func (*EventInterestWithdrawal) ProtoMessage()    {}
func (*EventInterestWithdrawal) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{8}
}
func (m *EventInterestWithdrawal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventInterestWithdrawal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventInterestWithdrawal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventInterestWithdrawal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventInterestWithdrawal.Merge(m, src)
}
func (m *EventInterestWithdrawal) XXX_Size() int {
	return m.Size()
}
func (m *EventInterestWithdrawal) XXX_DiscardUnknown() {
	xxx_messageInfo_EventInterestWithdrawal.DiscardUnknown(m)
}

var xxx_messageInfo_EventInterestWithdrawal proto.InternalMessageInfo

func (m *EventInterestWithdrawal) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventInterestWithdrawal) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventInterestWithdrawal) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// EventToggleSwapIn is an event emitted when swap-in operations are enabled or disabled for a vault.
type EventToggleSwapIn struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that toggled the swap-in operations.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// enabled is the new state of swap-in operations.
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *EventToggleSwapIn) Reset()         { *m = EventToggleSwapIn{} }
func (m *EventToggleSwapIn) String() string { return proto.CompactTextString(m) }
func (*EventToggleSwapIn) ProtoMessage()    {}
func (*EventToggleSwapIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{9}
}
func (m *EventToggleSwapIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventToggleSwapIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventToggleSwapIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventToggleSwapIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventToggleSwapIn.Merge(m, src)
}
func (m *EventToggleSwapIn) XXX_Size() int {
	return m.Size()
}
func (m *EventToggleSwapIn) XXX_DiscardUnknown() {
	xxx_messageInfo_EventToggleSwapIn.DiscardUnknown(m)
}

var xxx_messageInfo_EventToggleSwapIn proto.InternalMessageInfo

func (m *EventToggleSwapIn) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventToggleSwapIn) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventToggleSwapIn) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// EventToggleSwapOut is an event emitted when swap-out operations are enabled or disabled for a vault.
type EventToggleSwapOut struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that toggled the swap-out operations.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// enabled is the new state of swap-out operations.
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *EventToggleSwapOut) Reset()         { *m = EventToggleSwapOut{} }
func (m *EventToggleSwapOut) String() string { return proto.CompactTextString(m) }
func (*EventToggleSwapOut) ProtoMessage()    {}
func (*EventToggleSwapOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{10}
}
func (m *EventToggleSwapOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventToggleSwapOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventToggleSwapOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventToggleSwapOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventToggleSwapOut.Merge(m, src)
}
func (m *EventToggleSwapOut) XXX_Size() int {
	return m.Size()
}
func (m *EventToggleSwapOut) XXX_DiscardUnknown() {
	xxx_messageInfo_EventToggleSwapOut.DiscardUnknown(m)
}

var xxx_messageInfo_EventToggleSwapOut proto.InternalMessageInfo

func (m *EventToggleSwapOut) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventToggleSwapOut) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventToggleSwapOut) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// EventDepositPrincipalFunds is an event emitted when principal funds are deposited by the admin.
type EventDepositPrincipalFunds struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that deposited the funds.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// amount is the amount of funds deposited.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventDepositPrincipalFunds) Reset()         { *m = EventDepositPrincipalFunds{} }
func (m *EventDepositPrincipalFunds) String() string { return proto.CompactTextString(m) }
func (*EventDepositPrincipalFunds) ProtoMessage()    {}
func (*EventDepositPrincipalFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{11}
}
func (m *EventDepositPrincipalFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventDepositPrincipalFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventDepositPrincipalFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventDepositPrincipalFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventDepositPrincipalFunds.Merge(m, src)
}
func (m *EventDepositPrincipalFunds) XXX_Size() int {
	return m.Size()
}
func (m *EventDepositPrincipalFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_EventDepositPrincipalFunds.DiscardUnknown(m)
}

var xxx_messageInfo_EventDepositPrincipalFunds proto.InternalMessageInfo

func (m *EventDepositPrincipalFunds) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventDepositPrincipalFunds) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventDepositPrincipalFunds) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// EventWithdrawPrincipalFunds is an event emitted when principal funds are withdrawn by the admin.
type EventWithdrawPrincipalFunds struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that withdrew the funds.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// amount is the amount of funds withdrawn.
	Amount string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *EventWithdrawPrincipalFunds) Reset()         { *m = EventWithdrawPrincipalFunds{} }
func (m *EventWithdrawPrincipalFunds) String() string { return proto.CompactTextString(m) }
func (*EventWithdrawPrincipalFunds) ProtoMessage()    {}
func (*EventWithdrawPrincipalFunds) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{12}
}
func (m *EventWithdrawPrincipalFunds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventWithdrawPrincipalFunds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventWithdrawPrincipalFunds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventWithdrawPrincipalFunds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventWithdrawPrincipalFunds.Merge(m, src)
}
func (m *EventWithdrawPrincipalFunds) XXX_Size() int {
	return m.Size()
}
func (m *EventWithdrawPrincipalFunds) XXX_DiscardUnknown() {
	xxx_messageInfo_EventWithdrawPrincipalFunds.DiscardUnknown(m)
}

var xxx_messageInfo_EventWithdrawPrincipalFunds proto.InternalMessageInfo

func (m *EventWithdrawPrincipalFunds) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventWithdrawPrincipalFunds) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventWithdrawPrincipalFunds) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// EventMinInterestRateUpdated is emitted when the minimum interest rate is updated.
type EventMinInterestRateUpdated struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that updated the limit.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// min_rate is the newly set minimum annual interest rate as a decimal string (e.g., "0.9" for 90% and "0.9001353" for 90.01353%).
	// An empty string "" represents no minimum.
	MinRate string `protobuf:"bytes,3,opt,name=min_rate,json=minRate,proto3" json:"min_rate,omitempty"`
}

func (m *EventMinInterestRateUpdated) Reset()         { *m = EventMinInterestRateUpdated{} }
func (m *EventMinInterestRateUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMinInterestRateUpdated) ProtoMessage()    {}
func (*EventMinInterestRateUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{13}
}
func (m *EventMinInterestRateUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMinInterestRateUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMinInterestRateUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMinInterestRateUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMinInterestRateUpdated.Merge(m, src)
}
func (m *EventMinInterestRateUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMinInterestRateUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMinInterestRateUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMinInterestRateUpdated proto.InternalMessageInfo

func (m *EventMinInterestRateUpdated) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventMinInterestRateUpdated) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventMinInterestRateUpdated) GetMinRate() string {
	if m != nil {
		return m.MinRate
	}
	return ""
}

// EventMaxInterestRateUpdated is emitted when the maximum interest rate is updated.
type EventMaxInterestRateUpdated struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that updated the limit.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// max_rate is the newly set maximum annual interest rate as a decimal string (e.g., "0.9" for 90% and "0.9001353" for 90.01353%).
	// An empty string "" represents no maximum.
	MaxRate string `protobuf:"bytes,3,opt,name=max_rate,json=maxRate,proto3" json:"max_rate,omitempty"`
}

func (m *EventMaxInterestRateUpdated) Reset()         { *m = EventMaxInterestRateUpdated{} }
func (m *EventMaxInterestRateUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMaxInterestRateUpdated) ProtoMessage()    {}
func (*EventMaxInterestRateUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{14}
}
func (m *EventMaxInterestRateUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMaxInterestRateUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMaxInterestRateUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMaxInterestRateUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMaxInterestRateUpdated.Merge(m, src)
}
func (m *EventMaxInterestRateUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMaxInterestRateUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMaxInterestRateUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMaxInterestRateUpdated proto.InternalMessageInfo

func (m *EventMaxInterestRateUpdated) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventMaxInterestRateUpdated) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventMaxInterestRateUpdated) GetMaxRate() string {
	if m != nil {
		return m.MaxRate
	}
	return ""
}

// EventSwapOutRequested is emitted when a user successfully queues a swap out.
type EventSwapOutRequested struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// owner is the bech32 address of the user who initiated the swap out.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// redeem_denom is the denomination of the asset to be redeemed.
	RedeemDenom string `protobuf:"bytes,3,opt,name=redeem_denom,json=redeemDenom,proto3" json:"redeem_denom,omitempty"`
	// shares is the amount of vault shares the user escrowed for this request.
	Shares string `protobuf:"bytes,4,opt,name=shares,proto3" json:"shares,omitempty"`
	// request_id is the unique identifier for this pending swap out request.
	RequestId uint64 `protobuf:"varint,5,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *EventSwapOutRequested) Reset()         { *m = EventSwapOutRequested{} }
func (m *EventSwapOutRequested) String() string { return proto.CompactTextString(m) }
func (*EventSwapOutRequested) ProtoMessage()    {}
func (*EventSwapOutRequested) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{15}
}
func (m *EventSwapOutRequested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapOutRequested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapOutRequested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapOutRequested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapOutRequested.Merge(m, src)
}
func (m *EventSwapOutRequested) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapOutRequested) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapOutRequested.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapOutRequested proto.InternalMessageInfo

func (m *EventSwapOutRequested) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventSwapOutRequested) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventSwapOutRequested) GetRedeemDenom() string {
	if m != nil {
		return m.RedeemDenom
	}
	return ""
}

func (m *EventSwapOutRequested) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

func (m *EventSwapOutRequested) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

// EventSwapOutCompleted is emitted when a pending swap out is successfully processed.
type EventSwapOutCompleted struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// owner is the bech32 address of the user who received the payout.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// assets is the amount of assets paid out to the user.
	Assets string `protobuf:"bytes,3,opt,name=assets,proto3" json:"assets,omitempty"`
	// request_id is the unique identifier of the swap out request that was completed.
	RequestId uint64 `protobuf:"varint,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *EventSwapOutCompleted) Reset()         { *m = EventSwapOutCompleted{} }
func (m *EventSwapOutCompleted) String() string { return proto.CompactTextString(m) }
func (*EventSwapOutCompleted) ProtoMessage()    {}
func (*EventSwapOutCompleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{16}
}
func (m *EventSwapOutCompleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapOutCompleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapOutCompleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapOutCompleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapOutCompleted.Merge(m, src)
}
func (m *EventSwapOutCompleted) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapOutCompleted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapOutCompleted.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapOutCompleted proto.InternalMessageInfo

func (m *EventSwapOutCompleted) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventSwapOutCompleted) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventSwapOutCompleted) GetAssets() string {
	if m != nil {
		return m.Assets
	}
	return ""
}

func (m *EventSwapOutCompleted) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

// EventSwapOutRefunded is emitted when a pending swap out fails and the user's
// escrowed shares are returned.
type EventSwapOutRefunded struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// owner is the bech32 address of the user whose shares were refunded.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// shares is the amount of vault shares that were returned to the user.
	Shares string `protobuf:"bytes,3,opt,name=shares,proto3" json:"shares,omitempty"`
	// request_id is the unique identifier of the swap out request that failed.
	RequestId uint64 `protobuf:"varint,4,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// reason is a string detailing why the swap out failed.
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *EventSwapOutRefunded) Reset()         { *m = EventSwapOutRefunded{} }
func (m *EventSwapOutRefunded) String() string { return proto.CompactTextString(m) }
func (*EventSwapOutRefunded) ProtoMessage()    {}
func (*EventSwapOutRefunded) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{17}
}
func (m *EventSwapOutRefunded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSwapOutRefunded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSwapOutRefunded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSwapOutRefunded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSwapOutRefunded.Merge(m, src)
}
func (m *EventSwapOutRefunded) XXX_Size() int {
	return m.Size()
}
func (m *EventSwapOutRefunded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSwapOutRefunded.DiscardUnknown(m)
}

var xxx_messageInfo_EventSwapOutRefunded proto.InternalMessageInfo

func (m *EventSwapOutRefunded) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventSwapOutRefunded) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *EventSwapOutRefunded) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

func (m *EventSwapOutRefunded) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *EventSwapOutRefunded) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EventPendingSwapOutExpedited is an event emitted when a pending swap-out is expedited by the admin.
type EventPendingSwapOutExpedited struct {
	// request_id is the numerical identifier of the pending swap-out.
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// vault is the bech32 address of the vault.
	Vault string `protobuf:"bytes,2,opt,name=vault,proto3" json:"vault,omitempty"`
	// admin is the address of the account that expedited the swap-out.
	Admin string `protobuf:"bytes,3,opt,name=admin,proto3" json:"admin,omitempty"`
}

func (m *EventPendingSwapOutExpedited) Reset()         { *m = EventPendingSwapOutExpedited{} }
func (m *EventPendingSwapOutExpedited) String() string { return proto.CompactTextString(m) }
func (*EventPendingSwapOutExpedited) ProtoMessage()    {}
func (*EventPendingSwapOutExpedited) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{18}
}
func (m *EventPendingSwapOutExpedited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventPendingSwapOutExpedited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventPendingSwapOutExpedited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventPendingSwapOutExpedited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventPendingSwapOutExpedited.Merge(m, src)
}
func (m *EventPendingSwapOutExpedited) XXX_Size() int {
	return m.Size()
}
func (m *EventPendingSwapOutExpedited) XXX_DiscardUnknown() {
	xxx_messageInfo_EventPendingSwapOutExpedited.DiscardUnknown(m)
}

var xxx_messageInfo_EventPendingSwapOutExpedited proto.InternalMessageInfo

func (m *EventPendingSwapOutExpedited) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *EventPendingSwapOutExpedited) GetVault() string {
	if m != nil {
		return m.Vault
	}
	return ""
}

func (m *EventPendingSwapOutExpedited) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

// EventVaultPaused is emitted when a vault is paused.
type EventVaultPaused struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that paused the vault.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// reason is the reason for pausing the vault.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// total_vault_value is the total value of the vault's assets at the time of pausing.
	TotalVaultValue string `protobuf:"bytes,4,opt,name=total_vault_value,json=totalVaultValue,proto3" json:"total_vault_value,omitempty"`
}

func (m *EventVaultPaused) Reset()         { *m = EventVaultPaused{} }
func (m *EventVaultPaused) String() string { return proto.CompactTextString(m) }
func (*EventVaultPaused) ProtoMessage()    {}
func (*EventVaultPaused) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{19}
}
func (m *EventVaultPaused) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVaultPaused) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVaultPaused.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVaultPaused) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVaultPaused.Merge(m, src)
}
func (m *EventVaultPaused) XXX_Size() int {
	return m.Size()
}
func (m *EventVaultPaused) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVaultPaused.DiscardUnknown(m)
}

var xxx_messageInfo_EventVaultPaused proto.InternalMessageInfo

func (m *EventVaultPaused) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventVaultPaused) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventVaultPaused) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *EventVaultPaused) GetTotalVaultValue() string {
	if m != nil {
		return m.TotalVaultValue
	}
	return ""
}

// EventVaultUnpaused is emitted when a vault is unpaused.
type EventVaultUnpaused struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that unpaused the vault.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// total_vault_value is the new total value of the vault's assets at the time of unpausing.
	TotalVaultValue string `protobuf:"bytes,3,opt,name=total_vault_value,json=totalVaultValue,proto3" json:"total_vault_value,omitempty"`
}

func (m *EventVaultUnpaused) Reset()         { *m = EventVaultUnpaused{} }
func (m *EventVaultUnpaused) String() string { return proto.CompactTextString(m) }
func (*EventVaultUnpaused) ProtoMessage()    {}
func (*EventVaultUnpaused) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{20}
}
func (m *EventVaultUnpaused) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVaultUnpaused) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVaultUnpaused.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVaultUnpaused) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVaultUnpaused.Merge(m, src)
}
func (m *EventVaultUnpaused) XXX_Size() int {
	return m.Size()
}
func (m *EventVaultUnpaused) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVaultUnpaused.DiscardUnknown(m)
}

var xxx_messageInfo_EventVaultUnpaused proto.InternalMessageInfo

func (m *EventVaultUnpaused) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventVaultUnpaused) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventVaultUnpaused) GetTotalVaultValue() string {
	if m != nil {
		return m.TotalVaultValue
	}
	return ""
}

// EventBridgeAddressSet is emitted when the bridge address for a vault is configured or updated.
type EventBridgeAddressSet struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that set the bridge address.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// bridge_address is the configured external address allowed to mint/burn shares.
	BridgeAddress string `protobuf:"bytes,3,opt,name=bridge_address,json=bridgeAddress,proto3" json:"bridge_address,omitempty"`
}

func (m *EventBridgeAddressSet) Reset()         { *m = EventBridgeAddressSet{} }
func (m *EventBridgeAddressSet) String() string { return proto.CompactTextString(m) }
func (*EventBridgeAddressSet) ProtoMessage()    {}
func (*EventBridgeAddressSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{21}
}
func (m *EventBridgeAddressSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeAddressSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeAddressSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeAddressSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeAddressSet.Merge(m, src)
}
func (m *EventBridgeAddressSet) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeAddressSet) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeAddressSet.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeAddressSet proto.InternalMessageInfo

func (m *EventBridgeAddressSet) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventBridgeAddressSet) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventBridgeAddressSet) GetBridgeAddress() string {
	if m != nil {
		return m.BridgeAddress
	}
	return ""
}

// EventBridgeToggled is emitted when the bridge functionality is enabled or disabled for a vault.
type EventBridgeToggled struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// admin is the address of the account that toggled bridge functionality.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// enabled is the new state of the bridge functionality.
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *EventBridgeToggled) Reset()         { *m = EventBridgeToggled{} }
func (m *EventBridgeToggled) String() string { return proto.CompactTextString(m) }
func (*EventBridgeToggled) ProtoMessage()    {}
func (*EventBridgeToggled) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{22}
}
func (m *EventBridgeToggled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeToggled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeToggled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeToggled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeToggled.Merge(m, src)
}
func (m *EventBridgeToggled) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeToggled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeToggled.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeToggled proto.InternalMessageInfo

func (m *EventBridgeToggled) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventBridgeToggled) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *EventBridgeToggled) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// EventBridgeMintShares is emitted when shares are minted via the bridge flow.
type EventBridgeMintShares struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// bridge is the bech32 address of the bridge signer.
	Bridge string `protobuf:"bytes,2,opt,name=bridge,proto3" json:"bridge,omitempty"`
	// shares is the amount of shares minted.
	Shares string `protobuf:"bytes,3,opt,name=shares,proto3" json:"shares,omitempty"`
}

func (m *EventBridgeMintShares) Reset()         { *m = EventBridgeMintShares{} }
func (m *EventBridgeMintShares) String() string { return proto.CompactTextString(m) }
func (*EventBridgeMintShares) ProtoMessage()    {}
func (*EventBridgeMintShares) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{23}
}
func (m *EventBridgeMintShares) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeMintShares) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeMintShares.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeMintShares) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeMintShares.Merge(m, src)
}
func (m *EventBridgeMintShares) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeMintShares) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeMintShares.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeMintShares proto.InternalMessageInfo

func (m *EventBridgeMintShares) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventBridgeMintShares) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *EventBridgeMintShares) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

// EventBridgeBurnShares is emitted when shares are burned via the bridge flow.
type EventBridgeBurnShares struct {
	// vault_address is the bech32 address of the vault.
	VaultAddress string `protobuf:"bytes,1,opt,name=vault_address,json=vaultAddress,proto3" json:"vault_address,omitempty"`
	// bridge is the bech32 address of the bridge signer.
	Bridge string `protobuf:"bytes,2,opt,name=bridge,proto3" json:"bridge,omitempty"`
	// shares is the amount of shares burned.
	Shares string `protobuf:"bytes,3,opt,name=shares,proto3" json:"shares,omitempty"`
}

func (m *EventBridgeBurnShares) Reset()         { *m = EventBridgeBurnShares{} }
func (m *EventBridgeBurnShares) String() string { return proto.CompactTextString(m) }
func (*EventBridgeBurnShares) ProtoMessage()    {}
func (*EventBridgeBurnShares) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fb7c27aa4ee0453, []int{24}
}
func (m *EventBridgeBurnShares) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBridgeBurnShares) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBridgeBurnShares.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBridgeBurnShares) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBridgeBurnShares.Merge(m, src)
}
func (m *EventBridgeBurnShares) XXX_Size() int {
	return m.Size()
}
func (m *EventBridgeBurnShares) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBridgeBurnShares.DiscardUnknown(m)
}

var xxx_messageInfo_EventBridgeBurnShares proto.InternalMessageInfo

func (m *EventBridgeBurnShares) GetVaultAddress() string {
	if m != nil {
		return m.VaultAddress
	}
	return ""
}

func (m *EventBridgeBurnShares) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *EventBridgeBurnShares) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

func init() {
	proto.RegisterType((*EventDeposit)(nil), "provlabs.vault.v1.EventDeposit")
	proto.RegisterType((*EventWithdraw)(nil), "provlabs.vault.v1.EventWithdraw")
	proto.RegisterType((*EventVaultCreated)(nil), "provlabs.vault.v1.EventVaultCreated")
	proto.RegisterType((*EventSwapIn)(nil), "provlabs.vault.v1.EventSwapIn")
	proto.RegisterType((*EventSwapOut)(nil), "provlabs.vault.v1.EventSwapOut")
	proto.RegisterType((*EventVaultReconcile)(nil), "provlabs.vault.v1.EventVaultReconcile")
	proto.RegisterType((*EventVaultInterestChange)(nil), "provlabs.vault.v1.EventVaultInterestChange")
	proto.RegisterType((*EventInterestDeposit)(nil), "provlabs.vault.v1.EventInterestDeposit")
	proto.RegisterType((*EventInterestWithdrawal)(nil), "provlabs.vault.v1.EventInterestWithdrawal")
	proto.RegisterType((*EventToggleSwapIn)(nil), "provlabs.vault.v1.EventToggleSwapIn")
	proto.RegisterType((*EventToggleSwapOut)(nil), "provlabs.vault.v1.EventToggleSwapOut")
	proto.RegisterType((*EventDepositPrincipalFunds)(nil), "provlabs.vault.v1.EventDepositPrincipalFunds")
	proto.RegisterType((*EventWithdrawPrincipalFunds)(nil), "provlabs.vault.v1.EventWithdrawPrincipalFunds")
	proto.RegisterType((*EventMinInterestRateUpdated)(nil), "provlabs.vault.v1.EventMinInterestRateUpdated")
	proto.RegisterType((*EventMaxInterestRateUpdated)(nil), "provlabs.vault.v1.EventMaxInterestRateUpdated")
	proto.RegisterType((*EventSwapOutRequested)(nil), "provlabs.vault.v1.EventSwapOutRequested")
	proto.RegisterType((*EventSwapOutCompleted)(nil), "provlabs.vault.v1.EventSwapOutCompleted")
	proto.RegisterType((*EventSwapOutRefunded)(nil), "provlabs.vault.v1.EventSwapOutRefunded")
	proto.RegisterType((*EventPendingSwapOutExpedited)(nil), "provlabs.vault.v1.EventPendingSwapOutExpedited")
	proto.RegisterType((*EventVaultPaused)(nil), "provlabs.vault.v1.EventVaultPaused")
	proto.RegisterType((*EventVaultUnpaused)(nil), "provlabs.vault.v1.EventVaultUnpaused")
	proto.RegisterType((*EventBridgeAddressSet)(nil), "provlabs.vault.v1.EventBridgeAddressSet")
	proto.RegisterType((*EventBridgeToggled)(nil), "provlabs.vault.v1.EventBridgeToggled")
	proto.RegisterType((*EventBridgeMintShares)(nil), "provlabs.vault.v1.EventBridgeMintShares")
	proto.RegisterType((*EventBridgeBurnShares)(nil), "provlabs.vault.v1.EventBridgeBurnShares")
}

func init() { proto.RegisterFile("provlabs/vault/v1/events.proto", fileDescriptor_5fb7c27aa4ee0453) }

var fileDescriptor_5fb7c27aa4ee0453 = []byte{
	// 1059 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x98, 0x3f, 0x6f, 0x23, 0xc5,
	0x1b, 0xc7, 0x33, 0x3f, 0x3b, 0x4e, 0xf2, 0xc4, 0xf9, 0xb7, 0xbf, 0x00, 0xce, 0x1d, 0xe7, 0xbb,
	0xf8, 0x0a, 0xee, 0x90, 0x70, 0xee, 0x04, 0x0d, 0x05, 0x42, 0x49, 0x2e, 0x48, 0x29, 0x4e, 0x44,
	0x1b, 0xee, 0x90, 0x68, 0xac, 0xb1, 0xe7, 0x89, 0x33, 0xd2, 0x7a, 0x76, 0x99, 0x9d, 0x75, 0x72,
	0xe2, 0x15, 0xd0, 0x41, 0x0f, 0x22, 0x12, 0x48, 0x34, 0x94, 0x74, 0x54, 0xd0, 0x40, 0x85, 0x4e,
	0x54, 0x94, 0x28, 0x79, 0x07, 0x74, 0x74, 0x68, 0xfe, 0x79, 0x6d, 0x93, 0xe0, 0x04, 0x4b, 0x39,
	0x77, 0x99, 0xef, 0x3e, 0xbb, 0xf3, 0xf9, 0x3e, 0x33, 0xf3, 0xcc, 0x13, 0x43, 0x35, 0x91, 0x71,
	0x37, 0xa2, 0xcd, 0x74, 0xa3, 0x4b, 0xb3, 0x48, 0x6d, 0x74, 0x1f, 0x6e, 0x60, 0x17, 0x85, 0x4a,
	0xeb, 0x89, 0x8c, 0x55, 0x1c, 0xac, 0xf8, 0xe7, 0x75, 0xf3, 0xbc, 0xde, 0x7d, 0x78, 0x63, 0xad,
	0x15, 0xa7, 0x9d, 0x38, 0x6d, 0x98, 0x80, 0x0d, 0x3b, 0xb0, 0xd1, 0xb5, 0x1f, 0x08, 0x94, 0x77,
	0xf4, 0xeb, 0x8f, 0x30, 0x89, 0x53, 0xae, 0x82, 0x07, 0x50, 0x6a, 0xd1, 0x28, 0x42, 0x59, 0x21,
	0x77, 0xc8, 0xbd, 0xb9, 0xad, 0xca, 0x6f, 0xdf, 0xbf, 0xb1, 0xea, 0x5e, 0xd9, 0x64, 0x4c, 0x62,
	0x9a, 0xee, 0x2b, 0xc9, 0x45, 0x3b, 0x74, 0x71, 0x41, 0x1d, 0xa6, 0xe3, 0x23, 0x81, 0xb2, 0xf2,
	0xbf, 0x11, 0x2f, 0xd8, 0xb0, 0xe0, 0x65, 0x28, 0xd1, 0x34, 0x45, 0x95, 0x56, 0x0a, 0xfa, 0x85,
	0xd0, 0x8d, 0xb4, 0x9e, 0x1e, 0x52, 0x89, 0x69, 0xa5, 0x68, 0x75, 0x3b, 0x0a, 0xd6, 0x60, 0xd6,
	0x38, 0x69, 0x70, 0x56, 0x99, 0xbe, 0x43, 0xee, 0x2d, 0x84, 0x33, 0x66, 0xbc, 0xcb, 0x6a, 0x7f,
	0x12, 0x58, 0x30, 0xf4, 0x1f, 0x72, 0x75, 0xc8, 0x24, 0x3d, 0xfa, 0x0f, 0xf8, 0x6f, 0xc1, 0xac,
	0xc4, 0x16, 0xf2, 0xee, 0x25, 0x1c, 0xf4, 0x22, 0x73, 0xd3, 0x85, 0xab, 0x9a, 0x2e, 0x5e, 0x60,
	0x7a, 0xfa, 0x42, 0xd3, 0xa5, 0x41, 0xd3, 0xbf, 0x12, 0x58, 0x31, 0xa6, 0x9f, 0x6a, 0x61, 0x5b,
	0x22, 0x55, 0xc8, 0x82, 0x77, 0x60, 0xc1, 0xbe, 0x40, 0xed, 0xf4, 0x23, 0xfd, 0x97, 0x4d, 0xb8,
	0xd3, 0xb4, 0x1f, 0xca, 0x3a, 0x5c, 0x8c, 0x5e, 0x44, 0x13, 0x16, 0xdc, 0x86, 0x79, 0x43, 0xda,
	0x60, 0x28, 0xe2, 0x8e, 0x5b, 0x49, 0x30, 0xd2, 0x23, 0xad, 0x04, 0xf7, 0x61, 0x39, 0x13, 0x0c,
	0x65, 0xf4, 0x8c, 0x8b, 0x76, 0xc3, 0xb8, 0x75, 0xd6, 0x97, 0x72, 0x7d, 0x53, 0xcb, 0xb5, 0x9f,
	0x08, 0xcc, 0x1b, 0x43, 0xfb, 0x47, 0x34, 0xd9, 0x15, 0x79, 0x6e, 0xc9, 0xe5, 0x72, 0x7b, 0x13,
	0xe6, 0x68, 0x27, 0xce, 0x84, 0x6a, 0x78, 0xfe, 0x70, 0xd6, 0x0a, 0xbb, 0x22, 0x78, 0x0d, 0x96,
	0x6c, 0x4a, 0x1b, 0x6e, 0xed, 0x98, 0x83, 0x5d, 0xb4, 0x72, 0xe8, 0xd4, 0x7f, 0x26, 0xb0, 0x78,
	0x95, 0x04, 0xd6, 0x7e, 0xf4, 0x07, 0x49, 0x9b, 0x78, 0x3f, 0x53, 0x57, 0x76, 0x71, 0x17, 0x16,
	0x1c, 0x68, 0x33, 0x93, 0x02, 0x99, 0x73, 0x52, 0xb6, 0xe2, 0x96, 0xd1, 0x82, 0x5b, 0x00, 0xce,
	0x6a, 0x9c, 0x29, 0x67, 0xc4, 0x99, 0xd7, 0x73, 0x8e, 0xe9, 0xe1, 0x2f, 0x02, 0xff, 0xcf, 0x77,
	0x56, 0x88, 0xad, 0x58, 0xb4, 0x78, 0x84, 0xe3, 0xee, 0xad, 0xfb, 0xb0, 0x9c, 0x48, 0x2e, 0x5a,
	0x3c, 0xa1, 0x51, 0xa3, 0x89, 0x07, 0xb1, 0x44, 0x67, 0x6e, 0xa9, 0xa7, 0x6f, 0x19, 0x59, 0xaf,
	0x56, 0x1e, 0x4a, 0x0f, 0x94, 0x3f, 0x60, 0xe1, 0x62, 0x4f, 0xde, 0xd4, 0x6a, 0x10, 0x40, 0x51,
	0x52, 0x85, 0x6e, 0x4b, 0x99, 0xbf, 0xb5, 0xa6, 0x78, 0x07, 0xcd, 0x49, 0x2a, 0x84, 0xe6, 0x6f,
	0xfd, 0x41, 0x2e, 0x14, 0x4a, 0x4c, 0x55, 0x03, 0xa9, 0xc9, 0x6b, 0xc9, 0x7e, 0xd0, 0xcb, 0x3b,
	0x46, 0xad, 0x7d, 0x45, 0xa0, 0x92, 0x7b, 0xdf, 0x75, 0x0f, 0xb7, 0x0f, 0xa9, 0x68, 0x8f, 0x9d,
	0x80, 0x75, 0x28, 0xb7, 0x32, 0x29, 0x51, 0xa8, 0x86, 0x81, 0xb6, 0xe6, 0xe7, 0x9d, 0x16, 0x6a,
	0xf6, 0x75, 0x28, 0x33, 0x4c, 0xb9, 0x44, 0x66, 0x43, 0xac, 0xeb, 0x79, 0xa7, 0xe9, 0x90, 0xda,
	0x97, 0x04, 0x56, 0x0d, 0xa1, 0x87, 0xf3, 0x25, 0xfb, 0x9a, 0x8f, 0xbe, 0x2e, 0x65, 0x66, 0xc7,
	0xf5, 0xea, 0xb7, 0x19, 0xd5, 0x4e, 0x08, 0xbc, 0x32, 0xc0, 0xe7, 0x8b, 0x32, 0x8d, 0x26, 0x05,
	0xf1, 0x0b, 0x5f, 0x3a, 0x3f, 0x88, 0xdb, 0xed, 0x08, 0x5d, 0xbd, 0xb9, 0x66, 0xb8, 0x0a, 0xcc,
	0xa0, 0xa0, 0xcd, 0xc8, 0x55, 0xa2, 0xd9, 0xd0, 0x0f, 0xf5, 0x0a, 0x07, 0x43, 0x78, 0xe7, 0x9e,
	0xea, 0x17, 0xc5, 0xf7, 0x35, 0x81, 0x1b, 0xfd, 0xcd, 0xc2, 0x9e, 0x3f, 0x93, 0xef, 0x65, 0x82,
	0xa5, 0x93, 0xb2, 0xc8, 0xdf, 0x10, 0xb8, 0x39, 0xd0, 0x14, 0x4c, 0x26, 0xe6, 0xb7, 0x1e, 0xf3,
	0x31, 0x17, 0xfe, 0xc4, 0xe8, 0x73, 0xfe, 0x24, 0x61, 0x2f, 0xe2, 0x42, 0x5f, 0x83, 0xd9, 0x0e,
	0x17, 0xfd, 0xc5, 0x67, 0xa6, 0xc3, 0x85, 0x29, 0x3c, 0x39, 0x29, 0x3d, 0x9e, 0x10, 0x52, 0x7a,
	0x3c, 0x48, 0x4a, 0x8f, 0x0d, 0xe9, 0x77, 0x04, 0x5e, 0xea, 0xbf, 0x84, 0x43, 0xfc, 0x38, 0xc3,
	0x54, 0x33, 0xde, 0x3d, 0x97, 0x71, 0x88, 0x64, 0x75, 0xa0, 0x93, 0xf5, 0x17, 0xf3, 0x3a, 0x94,
	0x25, 0x32, 0xc4, 0xce, 0x40, 0xaf, 0x33, 0x6f, 0x35, 0xdb, 0xec, 0x5c, 0xd4, 0xba, 0xde, 0x02,
	0x90, 0x16, 0xc1, 0x37, 0xaf, 0xc5, 0x70, 0xce, 0x29, 0xbb, 0xac, 0xf6, 0xe9, 0x10, 0xee, 0x76,
	0xdc, 0x49, 0x22, 0x1c, 0x13, 0xf7, 0xa2, 0xf6, 0x7a, 0x90, 0xa5, 0x38, 0xcc, 0x72, 0xe2, 0x6f,
	0x97, 0x5e, 0xea, 0x0e, 0x74, 0x9f, 0x36, 0x2e, 0x8a, 0x4b, 0x4b, 0xe1, 0x5f, 0xd2, 0x32, 0x8c,
	0xa2, 0x5f, 0x93, 0x48, 0xd3, 0x58, 0xf8, 0x9e, 0xd8, 0x8e, 0x74, 0x79, 0x7c, 0xd5, 0x20, 0xee,
	0xa1, 0x60, 0x5c, 0xb4, 0x1d, 0xe9, 0xce, 0x71, 0x82, 0x8c, 0x2b, 0xdb, 0x1d, 0xf5, 0x7d, 0x97,
	0x0c, 0x7f, 0xb7, 0x0e, 0xd3, 0x06, 0x7a, 0xf4, 0x46, 0x33, 0x61, 0xf9, 0xc6, 0x2c, 0x5c, 0x6a,
	0x63, 0xd6, 0x3e, 0x27, 0xb0, 0x9c, 0xb7, 0x10, 0x7b, 0x34, 0x4b, 0xaf, 0x90, 0xbe, 0xbe, 0x23,
	0xd0, 0x57, 0x39, 0x5c, 0x1e, 0x0a, 0xfd, 0x79, 0x08, 0x5e, 0x87, 0x15, 0x15, 0x2b, 0x1a, 0x35,
	0xec, 0x87, 0xbb, 0x34, 0xca, 0x7c, 0x23, 0xb4, 0x64, 0x1e, 0x98, 0xf9, 0x9f, 0x6a, 0xb9, 0xf6,
	0x89, 0xbb, 0x51, 0x8c, 0xf4, 0x44, 0x24, 0x63, 0x43, 0x9d, 0x3b, 0x79, 0xe1, 0xfc, 0xc9, 0x7f,
	0xf6, 0xfb, 0x7b, 0x4b, 0x72, 0xd6, 0x46, 0x9f, 0x34, 0xbc, 0xf6, 0x2b, 0xed, 0x5d, 0x58, 0x6c,
	0x1a, 0x84, 0xde, 0x7c, 0xa3, 0x96, 0x74, 0xa1, 0xd9, 0x8f, 0x9c, 0xdf, 0xcc, 0xd6, 0x89, 0xbd,
	0x9f, 0xd9, 0xe4, 0xdc, 0xcc, 0x27, 0x83, 0x99, 0x7e, 0xcc, 0x85, 0xda, 0xb7, 0x67, 0x6d, 0x4c,
	0xc4, 0x07, 0x50, 0xb2, 0x99, 0x18, 0xc9, 0xe8, 0xe2, 0x2e, 0x3a, 0xf4, 0xc3, 0x88, 0xfa, 0x1f,
	0x9a, 0x09, 0x43, 0xdc, 0x7a, 0xfb, 0x97, 0xd3, 0x2a, 0x79, 0x7e, 0x5a, 0x25, 0x7f, 0x9c, 0x56,
	0xc9, 0x67, 0x67, 0xd5, 0xa9, 0xe7, 0x67, 0xd5, 0xa9, 0xdf, 0xcf, 0xaa, 0x53, 0x1f, 0xdd, 0x6e,
	0x73, 0x75, 0x98, 0x35, 0xeb, 0xad, 0xb8, 0xb3, 0x31, 0xf4, 0xfb, 0x8b, 0x7a, 0x96, 0x60, 0xda,
	0x2c, 0x99, 0x9f, 0x53, 0xde, 0xfc, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xb5, 0x53, 0x91, 0x63, 0x9e,
	0x11, 0x00, 0x00,
}

func (m *EventDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.VaultId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Caller) > 0 {
		i -= len(m.Caller)
		copy(dAtA[i:], m.Caller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Caller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VaultId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.VaultId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Caller) > 0 {
		i -= len(m.Caller)
		copy(dAtA[i:], m.Caller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Caller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVaultCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVaultCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVaultCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnderlyingAsset) > 0 {
		i -= len(m.UnderlyingAsset)
		copy(dAtA[i:], m.UnderlyingAsset)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.UnderlyingAsset)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ShareDenom) > 0 {
		i -= len(m.ShareDenom)
		copy(dAtA[i:], m.ShareDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ShareDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SharesReceived) > 0 {
		i -= len(m.SharesReceived)
		copy(dAtA[i:], m.SharesReceived)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SharesReceived)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AmountIn) > 0 {
		i -= len(m.AmountIn)
		copy(dAtA[i:], m.AmountIn)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AmountIn)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AmountOut) > 0 {
		i -= len(m.AmountOut)
		copy(dAtA[i:], m.AmountOut)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AmountOut)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SharesBurned) > 0 {
		i -= len(m.SharesBurned)
		copy(dAtA[i:], m.SharesBurned)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SharesBurned)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVaultReconcile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVaultReconcile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVaultReconcile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterestEarned) > 0 {
		i -= len(m.InterestEarned)
		copy(dAtA[i:], m.InterestEarned)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.InterestEarned)))
		i--
		dAtA[i] = 0x32
	}
	if m.Time != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Rate) > 0 {
		i -= len(m.Rate)
		copy(dAtA[i:], m.Rate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Rate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PrincipalAfter) > 0 {
		i -= len(m.PrincipalAfter)
		copy(dAtA[i:], m.PrincipalAfter)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PrincipalAfter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PrincipalBefore) > 0 {
		i -= len(m.PrincipalBefore)
		copy(dAtA[i:], m.PrincipalBefore)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PrincipalBefore)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVaultInterestChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVaultInterestChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVaultInterestChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DesiredRate) > 0 {
		i -= len(m.DesiredRate)
		copy(dAtA[i:], m.DesiredRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DesiredRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CurrentRate) > 0 {
		i -= len(m.CurrentRate)
		copy(dAtA[i:], m.CurrentRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.CurrentRate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventInterestDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventInterestDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventInterestDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventInterestWithdrawal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventInterestWithdrawal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventInterestWithdrawal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventToggleSwapIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventToggleSwapIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventToggleSwapIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventToggleSwapOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventToggleSwapOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventToggleSwapOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventDepositPrincipalFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventDepositPrincipalFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventDepositPrincipalFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventWithdrawPrincipalFunds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventWithdrawPrincipalFunds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventWithdrawPrincipalFunds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMinInterestRateUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMinInterestRateUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMinInterestRateUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinRate) > 0 {
		i -= len(m.MinRate)
		copy(dAtA[i:], m.MinRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MinRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMaxInterestRateUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMaxInterestRateUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMaxInterestRateUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxRate) > 0 {
		i -= len(m.MaxRate)
		copy(dAtA[i:], m.MaxRate)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MaxRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapOutRequested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapOutRequested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapOutRequested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RedeemDenom) > 0 {
		i -= len(m.RedeemDenom)
		copy(dAtA[i:], m.RedeemDenom)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RedeemDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapOutCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapOutCompleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapOutCompleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Assets) > 0 {
		i -= len(m.Assets)
		copy(dAtA[i:], m.Assets)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Assets)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSwapOutRefunded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSwapOutRefunded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSwapOutRefunded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RequestId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventPendingSwapOutExpedited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventPendingSwapOutExpedited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventPendingSwapOutExpedited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vault) > 0 {
		i -= len(m.Vault)
		copy(dAtA[i:], m.Vault)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Vault)))
		i--
		dAtA[i] = 0x12
	}
	if m.RequestId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventVaultPaused) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVaultPaused) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVaultPaused) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalVaultValue) > 0 {
		i -= len(m.TotalVaultValue)
		copy(dAtA[i:], m.TotalVaultValue)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalVaultValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVaultUnpaused) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVaultUnpaused) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVaultUnpaused) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalVaultValue) > 0 {
		i -= len(m.TotalVaultValue)
		copy(dAtA[i:], m.TotalVaultValue)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TotalVaultValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeAddressSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeAddressSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeAddressSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BridgeAddress) > 0 {
		i -= len(m.BridgeAddress)
		copy(dAtA[i:], m.BridgeAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BridgeAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeToggled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeToggled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeToggled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeMintShares) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeMintShares) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeMintShares) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bridge) > 0 {
		i -= len(m.Bridge)
		copy(dAtA[i:], m.Bridge)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Bridge)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBridgeBurnShares) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBridgeBurnShares) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBridgeBurnShares) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Bridge) > 0 {
		i -= len(m.Bridge)
		copy(dAtA[i:], m.Bridge)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Bridge)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddress) > 0 {
		i -= len(m.VaultAddress)
		copy(dAtA[i:], m.VaultAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.VaultAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.VaultId != 0 {
		n += 1 + sovEvents(uint64(m.VaultId))
	}
	return n
}

func (m *EventWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.VaultId != 0 {
		n += 1 + sovEvents(uint64(m.VaultId))
	}
	return n
}

func (m *EventVaultCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.ShareDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.UnderlyingAsset)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSwapIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AmountIn)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SharesReceived)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSwapOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SharesBurned)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AmountOut)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventVaultReconcile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PrincipalBefore)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.PrincipalAfter)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Rate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovEvents(uint64(m.Time))
	}
	l = len(m.InterestEarned)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventVaultInterestChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.CurrentRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DesiredRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventInterestDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventInterestWithdrawal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventToggleSwapIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *EventToggleSwapOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *EventDepositPrincipalFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventWithdrawPrincipalFunds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMinInterestRateUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MinRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMaxInterestRateUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MaxRate)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventSwapOutRequested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.RedeemDenom)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovEvents(uint64(m.RequestId))
	}
	return n
}

func (m *EventSwapOutCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Assets)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovEvents(uint64(m.RequestId))
	}
	return n
}

func (m *EventSwapOutRefunded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovEvents(uint64(m.RequestId))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventPendingSwapOutExpedited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovEvents(uint64(m.RequestId))
	}
	l = len(m.Vault)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventVaultPaused) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalVaultValue)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventVaultUnpaused) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TotalVaultValue)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBridgeAddressSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.BridgeAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBridgeToggled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *EventBridgeMintShares) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventBridgeBurnShares) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultId", wireType)
			}
			m.VaultId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultId", wireType)
			}
			m.VaultId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VaultId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVaultCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVaultCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVaultCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShareDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderlyingAsset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnderlyingAsset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesReceived", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharesReceived = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharesBurned = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVaultReconcile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVaultReconcile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVaultReconcile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalBefore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrincipalBefore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrincipalAfter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrincipalAfter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterestEarned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterestEarned = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVaultInterestChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVaultInterestChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVaultInterestChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesiredRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventInterestDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventInterestDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventInterestDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventInterestWithdrawal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventInterestWithdrawal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventInterestWithdrawal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventToggleSwapIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventToggleSwapIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventToggleSwapIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventToggleSwapOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventToggleSwapOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventToggleSwapOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventDepositPrincipalFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventDepositPrincipalFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventDepositPrincipalFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventWithdrawPrincipalFunds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventWithdrawPrincipalFunds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventWithdrawPrincipalFunds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMinInterestRateUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMinInterestRateUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMinInterestRateUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMaxInterestRateUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMaxInterestRateUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMaxInterestRateUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapOutRequested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapOutRequested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapOutRequested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeemDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedeemDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapOutCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapOutCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapOutCompleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSwapOutRefunded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSwapOutRefunded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSwapOutRefunded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventPendingSwapOutExpedited) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventPendingSwapOutExpedited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventPendingSwapOutExpedited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vault", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vault = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVaultPaused) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVaultPaused: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVaultPaused: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalVaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVaultUnpaused) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVaultUnpaused: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVaultUnpaused: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalVaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeAddressSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeAddressSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeAddressSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BridgeAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeToggled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeToggled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeToggled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeMintShares) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeMintShares: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeMintShares: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBridgeBurnShares) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBridgeBurnShares: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBridgeBurnShares: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
